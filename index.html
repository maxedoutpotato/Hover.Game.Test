<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wipeout-like Racer</title>
    <style>
        /* Global styles for the body */
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a2e; /* Dark futuristic background */
            font-family: 'Inter', sans-serif; /* Modern font */
            color: #ffffff; /* White text */
            overflow: hidden; /* Prevent scrollbars */
        }

        /* Game container for UI and canvas */
        .game-container {
            background-color: #21213b; /* Slightly lighter dark background */
            border-radius: 15px; /* Rounded corners */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6); /* Stronger shadow */
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 95%; /* Responsive width */
            width: 800px; /* Max width for desktop */
            box-sizing: border-box;
            position: relative; /* For message box positioning */
        }

        /* Canvas styling */
        canvas {
            display: block;
            width: 100%; /* Make canvas responsive */
            height: 500px; /* Fixed height for game area */
            border-radius: 10px; /* Rounded corners for canvas */
            background-color: #000000; /* Black background for 3D scene */
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5); /* Inner shadow */
        }

        /* UI elements styling */
        .ui-panel {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 10px 0;
            background-color: #2c2c4a;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .ui-item {
            font-size: 1.2em;
            font-weight: bold;
            color: #8aff8a; /* Bright green for UI text */
            text-shadow: 0 0 5px rgba(138, 255, 138, 0.5);
        }

        /* Message box for game instructions/over */
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(33, 33, 59, 0.98); /* Semi-transparent dark background */
            border: 2px solid #8aff8a; /* Green border */
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: flex; /* Shown by default for instructions */
            flex-direction: column;
            gap: 15px;
            width: 90%;
            max-width: 500px;
            box-sizing: border-box;
        }

        .message-box h2 {
            color: #e0e0e0;
            margin-bottom: 10px;
            font-size: 2.2em;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .message-box p {
            color: #c0c0c0;
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        /* Button styling */
        .button {
            background: linear-gradient(145deg, #8aff8a, #4caf50); /* Green gradient */
            color: #1a1a2e; /* Dark text for contrast */
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button:hover {
            background: linear-gradient(145deg, #4caf50, #8aff8a); /* Reverse gradient on hover */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
                gap: 15px;
            }
            canvas {
                height: 400px;
            }
            .ui-item {
                font-size: 1em;
            }
            .message-box h2 {
                font-size: 1.8em;
            }
            .message-box p {
                font-size: 1em;
            }
            .button {
                padding: 10px 20px;
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .game-container {
                padding: 10px;
                gap: 10px;
            }
            canvas {
                height: 300px;
            }
            .ui-item {
                font-size: 0.9em;
            }
            .message-box h2 {
                font-size: 1.5em;
            }
            .message-box p {
                font-size: 0.9em;
            }
            .button {
                padding: 8px 15px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="ui-panel">
            <div class="ui-item">Speed: <span id="speedDisplay">0</span> km/h</div>
            <div class="ui-item">Time: <span id="timeDisplay">00:00</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="messageBox" class="message-box">
        <h2 id="messageTitle">Wipeout-like Racer</h2>
        <p id="messageText">
            Welcome to the futuristic racing experience!
            <br><br>
            <strong>Controls:</strong>
            <br>
            Use <strong>W / Arrow Up</strong> to accelerate.
            <br>
            Use <strong>S / Arrow Down</strong> to brake/reverse.
            <br>
            Use <strong>A / Arrow Left</strong> to steer left.
            <br>
            Use <strong>D / Arrow Right</strong> to steer right.
            <br><br>
            On touch devices, swipe left/right on the canvas to steer.
            <br><br>
            Your goal is to stay on the track and race against time!
        </p>
        <button id="startButton" class="button">Start Race</button>
        <button id="musicToggleButton" class="button">Toggle Music</button>
    </div>

    <audio id="backgroundMusic" loop>
        <!-- Updated to a different SoundHelix song that is usually reliable -->
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- DRACOLoader MUST be loaded BEFORE GLTFLoader if using UMD -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let world; // Cannon.js physics world
        let playerMesh, playerBody; // Three.js mesh and Cannon.js body for the player
        let mixer; // Animation mixer for the player ship
        let animations = {}; // Stores animation actions by name
        let clock = new THREE.Clock(); // For animation and physics time steps
        let canvas; // Declare canvas globally, assign in init

        let trackSegments = []; // Array to hold track segment meshes and bodies

        let keys = {}; // Object to track pressed keys
        let gameRunning = false;
        let gameTime = 0;
        let gameInterval = null; // Initialize to null
        let musicPlaying = false;
        let backgroundMusic;

        // UI elements
        const speedDisplay = document.getElementById('speedDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const startButton = document.getElementById('startButton');
        const musicToggleButton = document.getElementById('musicToggleButton');

        // Player movement parameters
        const maxSpeed = 70; // Max forward speed
        const acceleration = 7; // How fast player accelerates
        const brakingForce = 15; // How fast player brakes
        const steeringSpeed = 0.08; // How fast player turns (angular velocity)
        const hoverHeight = 1.0; // Desired height above ground
        const hoverStrength = 100; // Stronger upward force for hover
        const hoverDamping = 10; // Dampen vertical oscillations

        // Track generation parameters
        const trackSegmentLength = 20; // Approx length of your track segment in Blender units
        const numberOfSegments = 1; // Testing with a single segment for now
        const trackWidth = 8; // Half-width of the track (from center to edge)
        const trackHeight = 0.5; // Thickness of the track ground
        const wallThickness = 0.5; // Thickness of the side walls
        const wallHeight = 2.0; // Height of the side walls

        // --- Initialization ---
        function init() {
            canvas = document.getElementById('gameCanvas'); // Assign canvas here

            // Set up scene, camera, renderer
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black background

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Camera position will be set dynamically in updateCamera()

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); // Use the globally defined canvas
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight); // Use the globally defined canvas
            renderer.setPixelRatio(window.devicePixelRatio);

            // Set up Cannon.js physics world
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Standard gravity
            world.broadphase = new CANNON.SAPBroadphase(world);

            // Create materials for physics interactions
            const groundMaterial = new CANNON.Material("groundMaterial");
            const playerMaterial = new CANNON.Material("playerMaterial");
            const wallMaterial = new CANNON.Material("wallMaterial");

            const groundPlayerContact = new CANNON.ContactMaterial(groundMaterial, playerMaterial, {
                friction: 0.5,
                restitution: 0.1
            });
            world.addContactMaterial(groundPlayerContact);

            const playerWallContact = new CANNON.ContactMaterial(playerMaterial, wallMaterial, {
                friction: 0.1,
                restitution: 0.5
            });
            world.addContactMaterial(playerWallContact);

            // Add lighting - Increased intensities and added HemisphereLight
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Increased intensity
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, 0.5); // Sky color, ground color, intensity
            scene.add(hemisphereLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Increased intensity
            directionalLight.position.set(5, 10, 5).normalize(); // Adjusted position for better illumination
            scene.add(directionalLight);

            // Load Ship and Track
            const loader = new THREE.GLTFLoader();
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/'); // Path to Draco decoder files
            loader.setDRACOLoader(dracoLoader);
            console.log('DRACOLoader and GLTFLoader initialized and linked.');

            loadModels(playerMaterial, groundMaterial, wallMaterial, loader); 

            // Get background music element
            backgroundMusic = document.getElementById('backgroundMusic');
            backgroundMusic.volume = 0.3;

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            startButton.addEventListener('click', startGame);
            musicToggleButton.addEventListener('click', toggleMusic);

            // Touch controls (re-enabled)
            let touchStartX = 0;
            canvas.addEventListener('touchstart', (e) => {
                if (!gameRunning) return;
                touchStartX = e.touches[0].clientX;
                keys['w'] = true; // Auto-accelerate on touch
            });

            canvas.addEventListener('touchmove', (e) => {
                if (!gameRunning) return;
                const touchCurrentX = e.touches[0].clientX;
                const deltaX = touchCurrentX - touchStartX;

                if (deltaX > 20) { keys['d'] = true; keys['a'] = false; }
                else if (deltaX < -20) { keys['a'] = true; keys['d'] = false; }
                else { keys['a'] = false; keys['d'] = false; }
                touchStartX = touchCurrentX;
            });

            canvas.addEventListener('touchend', () => {
                keys['w'] = false; keys['a'] = false; keys['d'] = false;
            });

            animate();
        }

        // --- Model Loading ---
        function loadModels(playerMaterial, groundMaterial, wallMaterial, loader) {
            const defaultMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888, 
                metalness: 0.7,
                roughness: 0.3,
                side: THREE.DoubleSide
            });

            // Load Ship Model
            loader.load(
                'https://maxedoutpotato.github.io/Hover.Game.Test/Game.Ship.glb', 
                (gltf) => {
                    playerMesh = gltf.scene;
                    playerMesh.scale.set(1, 1, 1); // Original scale
                    
                    playerMesh.traverse((node) => {
                        if (node.isMesh) {
                            node.material = node.material || defaultMaterial; 
                        }
                    });
                    scene.add(playerMesh);
                    console.log("Ship model added to scene:", playerMesh);

                    // Position the ship relative to the origin for observation
                    playerMesh.position.set(0, hoverHeight + 0.5, 0); // Place on top of the track segment
                    // Apply 180-degree Y-rotation to player mesh to face forward (if needed)
                    playerMesh.rotation.y = Math.PI; 

                    // Setup Animation Mixer
                    mixer = new THREE.AnimationMixer(playerMesh);
                    gltf.animations.forEach((clip) => {
                        const action = mixer.clipAction(clip);
                        animations[clip.name] = action;
                        if (clip.name === 'Idle') { 
                            action.play();
                        } else {
                            action.setEffectiveWeight(0); 
                        }
                    });

                    // Cannon.js player body
                    const originalShipWidth = 5; 
                    const originalShipHeight = 1;
                    const originalShipDepth = 8;

                    const playerShape = new CANNON.Box(new CANNON.Vec3(
                        originalShipWidth / 2,
                        originalShipHeight / 2,
                        originalShipDepth / 2
                    ));
                    playerBody = new CANNON.Body({ mass: 5, material: playerMaterial });
                    playerBody.addShape(playerShape);
                    playerBody.position.set(0, hoverHeight + originalShipHeight / 2, 0); 
                    // Apply 180-degree Y-rotation to player physics body to match visual
                    playerBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
                    world.addBody(playerBody);
                },
                (xhr) => { console.log('Ship model ' + (xhr.loaded / xhr.total * 100) + '% loaded'); },
                (error) => { console.error('An error occurred loading the ship model:', error); }
            );

            // Load Track Segment Model (only one for now)
            loader.load(
                'https://maxedoutpotato.github.io/Hover.Game.Test/Game.Track.Section.001.glb', 
                (gltf) => {
                    const baseTrackSegmentMesh = gltf.scene;
                    baseTrackSegmentMesh.traverse((node) => {
                        if (node.isMesh) {
                            node.material = node.material || defaultMaterial;
                        }
                    });

                    // Handle single segment directly
                    if (numberOfSegments === 1) {
                        const segmentMesh = baseTrackSegmentMesh; // Use directly, no clone needed for single
                        segmentMesh.scale.set(1, 1, 1); 
                        
                        // --- Track Segment Rotation Fix ---
                        // Apply X-axis rotation to lay flat (Blender Z-up to Three.js Y-up)
                        segmentMesh.rotation.x = -Math.PI / 2; 
                        // Apply Y-axis rotation to face forward (if model's default front is backward)
                        segmentMesh.rotation.y = Math.PI; 
                        
                        scene.add(segmentMesh);
                        trackSegments.push(segmentMesh); // Add to array even if single

                        // Create Cannon.js physics bodies for this single segment
                        const segmentBody = new CANNON.Body({ mass: 0 }); 

                        const scaledTrackWidth = trackWidth;
                        const scaledTrackHeight = trackHeight;
                        const scaledWallThickness = wallThickness;
                        const scaledWallHeight = wallHeight;
                        const adjustedTrackSegmentLength = trackSegmentLength / 5; // Use this for physics body length

                        // Track Ground (flat part)
                        const groundShape = new CANNON.Box(new CANNON.Vec3(scaledTrackWidth, scaledTrackHeight / 2, adjustedTrackSegmentLength / 2)); 
                        const groundOffset = new CANNON.Vec3(0, -scaledTrackHeight / 2, 0); 
                        segmentBody.addShape(groundShape, groundOffset);

                        // Left Wall (sloped edge)
                        const leftWallShape = new CANNON.Box(new CANNON.Vec3(scaledWallThickness / 2, scaledWallHeight / 2, adjustedTrackSegmentLength / 2)); 
                        const leftWallOffset = new CANNON.Vec3(-(scaledTrackWidth - scaledWallThickness / 2), scaledWallHeight / 2, 0); 
                        segmentBody.addShape(leftWallShape, leftWallOffset);

                        // Right Wall (sloped edge)
                        const rightWallShape = new CANNON.Box(new CANNON.Vec3(scaledWallThickness / 2, scaledWallHeight / 2, adjustedTrackSegmentLength / 2)); 
                        const rightWallOffset = new CANNON.Vec3((scaledTrackWidth - scaledWallThickness / 2), scaledWallHeight / 2, 0); 
                        segmentBody.addShape(rightWallShape, rightWallOffset);

                        segmentBody.position.set(0, 0, 0); // Place at origin
                        // --- Track Physics Body Rotation Fix ---
                        let physicsRotation = new CANNON.Quaternion();
                        let tempQuaternionX = new CANNON.Quaternion();
                        let tempQuaternionY = new CANNON.Quaternion();

                        tempQuaternionX.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); 
                        tempQuaternionY.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
                        tempQuaternionY.mult(tempQuaternionX, segmentBody.quaternion); 
                        
                        world.addBody(segmentBody);
                    } else {
                        // Original loop for multiple segments (not active now)
                        const pathPoints = [];
                        const adjustedTrackSegmentLength = trackSegmentLength / 5; 
                        for (let i = 0; i < numberOfSegments; i++) { 
                            pathPoints.push(new THREE.Vector3(0, 0, i * adjustedTrackSegmentLength)); 
                        }
                        const trackPath = new THREE.CatmullRomCurve3(pathPoints);

                        for (let i = 0; i < numberOfSegments; i++) {
                            const segmentMesh = baseTrackSegmentMesh.clone();
                            segmentMesh.scale.set(1, 1, 1); 

                            const t = i / (numberOfSegments - 1);
                            const position = trackPath.getPointAt(t);
                            const tangent = trackPath.getTangentAt(t).normalize();
                            const up = new THREE.Vector3(0, 1, 0);
                            const axis = new THREE.Vector3().crossVectors(up, tangent).normalize();
                            const angle = Math.acos(up.dot(tangent));
                            const orientation = new THREE.Quaternion().setFromAxisAngle(axis, angle);

                            segmentMesh.position.copy(position);
                            segmentMesh.quaternion.copy(orientation); 
                            
                            segmentMesh.rotation.x = -Math.PI / 2; 
                            segmentMesh.rotation.y = Math.PI; 
                            
                            scene.add(segmentMesh);
                            trackSegments.push(segmentMesh);

                            const segmentBody = new CANNON.Body({ mass: 0 }); 

                            const scaledTrackWidth = trackWidth;
                            const scaledTrackHeight = trackHeight;
                            const scaledWallThickness = wallThickness;
                            const scaledWallHeight = wallHeight;

                            const groundShape = new CANNON.Box(new CANNON.Vec3(scaledTrackWidth, scaledTrackHeight / 2, adjustedTrackSegmentLength / 2)); 
                            const groundOffset = new CANNON.Vec3(0, -scaledTrackHeight / 2, 0); 
                            segmentBody.addShape(groundShape, groundOffset);

                            const leftWallShape = new CANNON.Box(new CANNON.Vec3(scaledWallThickness / 2, scaledWallHeight / 2, adjustedTrackSegmentLength / 2)); 
                            const leftWallOffset = new CANNON.Vec3(-(scaledTrackWidth - scaledWallThickness / 2), scaledWallHeight / 2, 0); 
                            segmentBody.addShape(leftWallShape, leftWallOffset);

                            const rightWallShape = new CANNON.Box(new CANNON.Vec3(scaledWallThickness / 2, scaledWallHeight / 2, adjustedTrackSegmentLength / 2)); 
                            const rightWallOffset = new CANNON.Vec3((scaledTrackWidth - scaledWallThickness / 2), scaledWallHeight / 2, 0); 
                            segmentBody.addShape(rightWallShape, rightWallOffset);

                            segmentBody.position.copy(position);
                            let physicsRotation = new CANNON.Quaternion();
                            let tempQuaternionX = new CANNON.Quaternion();
                            let tempQuaternionY = new CANNON.Quaternion();

                            tempQuaternionX.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); 
                            tempQuaternionY.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
                            tempQuaternionY.mult(tempQuaternionX, segmentBody.quaternion); 
                            
                            world.addBody(segmentBody);
                        }
                    }
                },
                (xhr) => { console.log('Track model ' + (xhr.loaded / xhr.total * 100) + '% loaded'); },
                (error) => { console.error('An error occurred loading the track segment model:', error); }
            );
        }

        function onWindowResize() {
            const newWidth = canvas.offsetWidth; 
            const newHeight = canvas.offsetHeight; 
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }

        // --- Event Handlers (re-enabled) ---
        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(event.key.toLowerCase())) {
                event.preventDefault(); 
            }
        }

        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        function startGame() {
            document.getElementById('messageBox').style.display = 'none';
            gameRunning = true;
            gameTime = 0;

            // Reset player position and velocity
            if (playerBody) {
                const originalShipHeight = 1;
                playerBody.position.set(0, hoverHeight + originalShipHeight / 2, 0); 
                playerBody.velocity.set(0, 0, 0);
                playerBody.angularVelocity.set(0, 0, 0);
                playerBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI); 
            }

            if (gameInterval) clearInterval(gameInterval); 
            gameInterval = setInterval(() => {
                if (gameRunning) {
                    gameTime++;
                    // updateTimeDisplay(); // Re-enable if UI is needed
                }
            }, 1000);

            if (!musicPlaying) {
                // backgroundMusic.play().catch(e => console.log("Music play blocked:", e)); // Re-enable if music needed
                musicPlaying = true; // Assume playing for now
            }
        }

        function endGame() {
            gameRunning = false;
            clearInterval(gameInterval);
            // Re-enable message box if needed
            // document.getElementById('messageBox').style.display = 'flex';
        }

        function toggleMusic() {
            if (backgroundMusic.paused) {
                backgroundMusic.play().then(() => {
                    musicPlaying = true;
                    // musicToggleButton.textContent = "Pause Music"; // Re-enable if UI is needed
                }).catch(e => console.log("Music play blocked:", e));
            } else {
                backgroundMusic.pause();
                musicPlaying = false;
                // musicToggleButton.textContent = "Play Music"; // Re-enable if UI is needed
            }
        }

        // --- Game Logic ---
        function updatePlayer() {
            if (!playerBody) return;

            const deltaTime = clock.getDelta(); 

            // Apply linear damping
            playerBody.linearDamping = 0.98; 
            playerBody.angularDamping = 0.9;

            // Hover System (Raycasting downwards)
            const rayFrom = playerBody.position;
            const rayTo = new CANNON.Vec3();
            rayFrom.vadd(new CANNON.Vec3(0, -hoverHeight - 10, 0), rayTo); 

            world.raycastAny(rayFrom, rayTo, (result) => {
                if (result.hasHit) {
                    const distance = rayFrom.distanceTo(result.hitPoint);
                    const heightDifference = hoverHeight - distance; 

                    const hoverForceMagnitude = heightDifference * hoverStrength - playerBody.velocity.y * hoverDamping;
                    const hoverForce = new CANNON.Vec3(0, hoverForceMagnitude, 0);
                    playerBody.applyForce(hoverForce, playerBody.position);
                } else {
                    playerBody.applyLocalForce(new CANNON.Vec3(0, -50, 0), playerBody.position); 
                }
            });

            // Apply Thrust (forward/backward)
            const localForward = new CANNON.Vec3(0, 0, 1);
            const worldForward = new CANNON.Vec3();
            playerBody.quaternion.vmult(localForward, worldForward); 

            const currentSpeed = playerBody.velocity.dot(worldForward); 

            if (keys['w'] || keys['arrowup']) {
                playerBody.applyLocalForce(
                    new CANNON.Vec3(0, 0, acceleration * 10), 
                    new CANNON.Vec3(0, 0, 0)
                );
            }
            if (keys['s'] || keys['arrowdown']) {
                playerBody.applyLocalForce(
                    new CANNON.Vec3(0, 0, -brakingForce * 10), 
                    new CANNON.Vec3(0, 0, 0)
                );
            }

            // Apply Steering (Yaw Rotation)
            if (keys['a'] || keys['arrowleft']) {
                playerBody.angularVelocity.y = steeringSpeed * 10;
            } else if (keys['d'] || keys['arrowright']) {
                playerBody.angularVelocity.y = -steeringSpeed * 10;
            } else {
                playerBody.angularVelocity.y *= 0.8; 
            }

            // Limit player speed
            const velocityMagnitude = playerBody.velocity.length();
            const scaledMaxSpeed = maxSpeed; 
            if (velocityMagnitude > scaledMaxSpeed) {
                playerBody.velocity.normalize();
                playerBody.velocity.scale(scaledMaxSpeed, playerBody.velocity);
            }

            // Update speed display
            speedDisplay.textContent = Math.round(velocityMagnitude * 3.6); 
            
            // Ship Animations
            if (mixer) {
                mixer.update(deltaTime); 
                // Example: Activate steering animations
                if (animations['Turn_Left'] && animations['Turn_Right']) {
                    if (keys['a'] || keys['arrowleft']) {
                        animations['Turn_Left'].setEffectiveWeight(1);
                        animations['Turn_Right'].setEffectiveWeight(0);
                    } else if (keys['d'] || keys['arrowright']) {
                        animations['Turn_Right'].setEffectiveWeight(1);
                        animations['Turn_Left'].setEffectiveWeight(0);
                    } else {
                        animations['Turn_Left'].setEffectiveWeight(0);
                        animations['Turn_Right'].setEffectiveWeight(0);
                    }
                }
                // Need to handle idle weight if other animations are active and then fade out
            }

            // End game if player falls off far below track
            if (playerBody.position.y < -50) { 
                endGame();
            }
        }

        function updateCamera() {
            if (!playerBody || !playerMesh) return;

            const playerPos = playerBody.position;
            const playerQuat = playerBody.quaternion;

            // Camera follow behind and slightly above
            const relativeCameraOffset = new THREE.Vector3(0, 0.5, -1.0); // Adjusted for closer view
            const cameraOffset = relativeCameraOffset.applyQuaternion(playerMesh.quaternion);

            camera.position.copy(playerPos).add(cameraOffset);
            camera.lookAt(playerPos.x, playerPos.y + 0.5, playerPos.z); 
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); 

            if (gameRunning) { // Only update physics and game logic if game is running
                world.step(1 / 60, delta); 
                updatePlayer();
                updateCamera(); 
            }

            if (mixer) { // Animations update regardless of gameRunning state
                mixer.update(delta);
            }
            
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
