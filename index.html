<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wipeout-like Racer</title>
    <style>
        /* Global styles for the body */
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a2e; /* Dark futuristic background */
            font-family: 'Inter', sans-serif; /* Modern font */
            color: #ffffff; /* White text */
            overflow: hidden; /* Prevent scrollbars */
        }

        /* Game container for UI and canvas */
        .game-container {
            background-color: #21213b; /* Slightly lighter dark background */
            border-radius: 15px; /* Rounded corners */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6); /* Stronger shadow */
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 95%; /* Responsive width */
            width: 800px; /* Max width for desktop */
            box-sizing: border-box;
            position: relative; /* For message box positioning */
        }

        /* Canvas styling */
        canvas {
            display: block;
            width: 100%; /* Make canvas responsive */
            height: 500px; /* Fixed height for game area */
            border-radius: 10px; /* Rounded corners for canvas */
            background-color: #000000; /* Black background for 3D scene */
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5); /* Inner shadow */
        }

        /* UI elements styling */
        .ui-panel {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 10px 0;
            background-color: #2c2c4a;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .ui-item {
            font-size: 1.2em;
            font-weight: bold;
            color: #8aff8a; /* Bright green for UI text */
            text-shadow: 0 0 5px rgba(138, 255, 138, 0.5);
        }

        /* Message box for game instructions/over */
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(33, 33, 59, 0.98); /* Semi-transparent dark background */
            border: 2px solid #8aff8a; /* Green border */
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: flex; /* Shown by default for instructions */
            flex-direction: column;
            gap: 15px;
            width: 90%;
            max-width: 500px;
            box-sizing: border-box;
        }

        .message-box h2 {
            color: #e0e0e0;
            margin-bottom: 10px;
            font-size: 2.2em;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .message-box p {
            color: #c0c0c0;
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        /* Button styling */
        .button {
            background: linear-gradient(145deg, #8aff8a, #4caf50); /* Green gradient */
            color: #1a1a2e; /* Dark text for contrast */
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button:hover {
            background: linear-gradient(145deg, #4caf50, #8aff8a); /* Reverse gradient on hover */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
                gap: 15px;
            }
            canvas {
                height: 400px;
            }
            .ui-item {
                font-size: 1em;
            }
            .message-box h2 {
                font-size: 1.8em;
            }
            .message-box p {
                font-size: 1em;
            }
            .button {
                padding: 10px 20px;
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .game-container {
                padding: 10px;
                gap: 10px;
            }
            canvas {
                height: 300px;
            }
            .ui-item {
                font-size: 0.9em;
            }
            .message-box h2 {
                font-size: 1.5em;
            }
            .message-box p {
                font-size: 0.9em;
            }
            .button {
                padding: 8px 15px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="ui-panel">
            <div class="ui-item">Speed: <span id="speedDisplay">0</span> km/h</div>
            <div class="ui-item">Time: <span id="timeDisplay">00:00</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="messageBox" class="message-box">
        <h2 id="messageTitle">Wipeout-like Racer</h2>
        <p id="messageText">
            Welcome to the futuristic racing experience!
            <br><br>
            <strong>Controls:</strong>
            <br>
            Use <strong>W / Arrow Up</strong> to accelerate.
            <br>
            Use <strong>S / Arrow Down</strong> to brake/reverse.
            <br>
            Use <strong>A / Arrow Left</strong> to steer left.
            <br>
            Use <strong>D / Arrow Right</strong> to steer right.
            <br><br>
            On touch devices, swipe left/right on the canvas to steer.
            <br><br>
            Your goal is to stay on the track and race against time!
        </p>
        <button id="startButton" class="button">Start Race</button>
        <button id="musicToggleButton" class="button">Toggle Music</button>
    </div>

    <audio id="backgroundMusic" loop>
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.3.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <!-- DRACOLoader MUST be loaded BEFORE GLTFLoader if using UMD -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer;
        let world; // Cannon.js physics world
        let playerMesh, playerBody; // Three.js mesh and Cannon.js body for the player
        let mixer; // Animation mixer for the player ship
        let animations = {}; // Stores animation actions by name
        let clock = new THREE.Clock(); // For animation and physics time steps
        let canvas; // Declare canvas globally, assign in init

        let trackSegments = []; // Array to hold track segment meshes and bodies

        let keys = {}; // Object to track pressed keys
        let gameRunning = false;
        let gameTime = 0;
        let gameInterval = null; // Initialize to null
        let musicPlaying = false;
        let backgroundMusic;

        // UI elements
        const speedDisplay = document.getElementById('speedDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const startButton = document.getElementById('startButton');
        const musicToggleButton = document.getElementById('musicToggleButton');

        // Player movement parameters
        const maxSpeed = 70; // Max forward speed
        const acceleration = 7; // How fast player accelerates
        const brakingForce = 15; // How fast player brakes
        const steeringSpeed = 0.08; // How fast player turns (angular velocity)
        const hoverHeight = 1.0; // Desired height above ground
        const hoverStrength = 100; // Stronger upward force for hover
        const hoverDamping = 10; // Dampen vertical oscillations

        // Track generation parameters
        const trackSegmentLength = 20; // Approx length of your track segment in Blender units
        const numberOfSegments = 100; // Number of segments for the straight test track
        const trackWidth = 8; // Half-width of the track (from center to edge)
        const trackHeight = 0.5; // Thickness of the track ground
        const wallThickness = 0.5; // Thickness of the side walls
        const wallHeight = 2.0; // Height of the side walls

        // --- Initialization ---
        function init() {
            canvas = document.getElementById('gameCanvas'); // Assign canvas here

            // Set up scene, camera, renderer
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black background

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -15); // Initial camera position behind player, adjusted for ship scale

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); // Use the globally defined canvas
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight); // Use the globally defined canvas
            renderer.setPixelRatio(window.devicePixelRatio);

            // Set up Cannon.js physics world
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Standard gravity
            world.broadphase = new CANNON.SAPBroadphase(world);

            // Create materials for physics interactions
            const groundMaterial = new CANNON.Material("groundMaterial");
            const playerMaterial = new CANNON.Material("playerMaterial");
            const wallMaterial = new CANNON.Material("wallMaterial");

            const groundPlayerContact = new CANNON.ContactMaterial(groundMaterial, playerMaterial, {
                friction: 0.5,
                restitution: 0.1
            });
            world.addContactMaterial(groundPlayerContact);

            const playerWallContact = new CANNON.ContactMaterial(playerMaterial, wallMaterial, {
                friction: 0.1,
                restitution: 0.5
            });
            world.addContactMaterial(playerWallContact);

            // Add lighting - Increased intensities and added HemisphereLight
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Increased intensity
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, 0.5); // Sky color, ground color, intensity
            scene.add(hemisphereLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Increased intensity
            directionalLight.position.set(5, 10, 5).normalize(); // Adjusted position for better illumination
            scene.add(directionalLight);

            // Load Ship and Track
            // Initialize loader and dracoLoader here, and pass them to loadModels
            const loader = new THREE.GLTFLoader();
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/'); // Path to Draco decoder files
            loader.setDRACOLoader(dracoLoader);
            console.log('DRACOLoader and GLTFLoader initialized and linked.');
            console.log('DRACOLoader instance:', dracoLoader);
            console.log('GLTFLoader instance:', loader);

            loadModels(playerMaterial, groundMaterial, wallMaterial, loader); // Pass the configured loader

            // Get background music element
            backgroundMusic = document.getElementById('backgroundMusic');
            backgroundMusic.volume = 0.3;

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            startButton.addEventListener('click', startGame);
            musicToggleButton.addEventListener('click', toggleMusic);

            // Touch controls (similar to previous game)
            let touchStartX = 0;
            canvas.addEventListener('touchstart', (e) => {
                if (!gameRunning) return;
                touchStartX = e.touches[0].clientX;
                keys['w'] = true; // Auto-accelerate on touch
            });

            canvas.addEventListener('touchmove', (e) => {
                if (!gameRunning) return;
                const touchCurrentX = e.touches[0].clientX;
                const deltaX = touchCurrentX - touchStartX;

                if (deltaX > 20) { keys['d'] = true; keys['a'] = false; }
                else if (deltaX < -20) { keys['a'] = true; keys['d'] = false; }
                else { keys['a'] = false; keys['d'] = false; }
                touchStartX = touchCurrentX;
            });

            canvas.addEventListener('touchend', () => {
                keys['w'] = false; keys['a'] = false; keys['d'] = false;
            });

            animate();
        }

        // --- Model Loading ---
        // Now accepts the pre-configured loader
        function loadModels(playerMaterial, groundMaterial, wallMaterial, loader) {
            // Define a temporary, bright material for debugging visibility
            const debugMaterial = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
            // Or a simple bright standard material:
            // const debugMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, side: THREE.DoubleSide, metalness: 0.5, roughness: 0.5 });


            // Load Ship Model
            loader.load(
                'https://maxedoutpotato.github.io/Hover.Game.Test/Game.Ship.glb', // Updated to GitHub Pages URL
                (gltf) => {
                    playerMesh = gltf.scene;
                    playerMesh.scale.set(0.5, 0.5, 0.5); // Adjust scale as needed
                    
                    // Apply debug material to all meshes in the ship model
                    playerMesh.traverse((node) => {
                        if (node.isMesh) {
                            node.material = debugMaterial;
                        }
                    });
                    scene.add(playerMesh);

                    // Setup Animation Mixer
                    mixer = new THREE.AnimationMixer(playerMesh);
                    gltf.animations.forEach((clip) => {
                        const action = mixer.clipAction(clip);
                        animations[clip.name] = action;
                        // Play idle animation by default
                        if (clip.name === 'Idle') { // Assuming your idle animation is named 'Idle'
                            action.play();
                        } else {
                            action.setEffectiveWeight(0); // Start other animations at zero influence
                        }
                    });

                    // Cannon.js player body - adjusted for Manta Ray shape
                    // Approximate with a box for simplicity, adjust half extents
                    const playerShape = new CANNON.Box(new CANNON.Vec3(2.5 * 0.5, 0.5 * 0.5, 4 * 0.5)); // Width, Height, Depth (scaled)
                    playerBody = new CANNON.Body({ mass: 5, material: playerMaterial });
                    playerBody.addShape(playerShape);
                    playerBody.position.set(0, hoverHeight + 0.5, 0); // Start slightly above ground
                    world.addBody(playerBody);
                },
                (xhr) => {
                    console.log('Ship model ' + (xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    console.error('An error occurred loading the ship model:', error);
                    console.warn('Possible reason: GitHub Pages might not be enabled for your repository, or the file paths are incorrect. Please ensure GitHub Pages is enabled and the files are directly accessible at the provided URLs.');
                }
            );

            // Load Track Segment Model and duplicate
            loader.load(
                'https://maxedoutpotato.github.io/Hover.Game.Test/Game.Track.Section.001.glb', // Updated to GitHub Pages URL
                (gltf) => {
                    const baseTrackSegmentMesh = gltf.scene;
                    baseTrackSegmentMesh.traverse((node) => {
                        // Apply debug material to all meshes in the track segment
                        if (node.isMesh) {
                            node.material = debugMaterial;
                        }
                    });

                    // Create a straight path for duplication
                    const pathPoints = [];
                    for (let i = 0; i <= numberOfSegments; i++) {
                        pathPoints.push(new THREE.Vector3(0, 0, i * trackSegmentLength));
                    }
                    const trackPath = new THREE.CatmullRomCurve3(pathPoints);

                    // Duplicate track segments
                    for (let i = 0; i < numberOfSegments; i++) {
                        const segmentMesh = baseTrackSegmentMesh.clone();

                        // Calculate position and orientation along the path
                        const t = i / (numberOfSegments - 1);
                        const position = trackPath.getPointAt(t);
                        const tangent = trackPath.getTangentAt(t).normalize();
                        const up = new THREE.Vector3(0, 1, 0);
                        const axis = new THREE.Vector3().crossVectors(up, tangent).normalize();
                        const angle = Math.acos(up.dot(tangent));
                        const orientation = new THREE.Quaternion().setFromAxisAngle(axis, angle);

                        segmentMesh.position.copy(position);
                        segmentMesh.quaternion.copy(orientation); // Orient the segment along the path
                        segmentMesh.rotation.y += Math.PI; // Adjust rotation to face forward if needed based on model's default orientation

                        scene.add(segmentMesh);
                        trackSegments.push(segmentMesh);

                        // Create Cannon.js physics bodies for each segment
                        // Assuming your segment is centered at origin and has width/length for simple box colliders
                        const segmentBody = new CANNON.Body({ mass: 0 }); // Static body

                        // Track Ground (flat part)
                        const groundShape = new CANNON.Box(new CANNON.Vec3(trackWidth, trackHeight / 2, trackSegmentLength / 2));
                        const groundOffset = new CANNON.Vec3(0, -trackHeight / 2, 0);
                        segmentBody.addShape(groundShape, groundOffset);

                        // Left Wall (sloped edge) - simplified as a box for now, adjust position/rotation later for 30-45 deg
                        const leftWallShape = new CANNON.Box(new CANNON.Vec3(wallThickness / 2, wallHeight / 2, trackSegmentLength / 2));
                        const leftWallOffset = new CANNON.Vec3(-(trackWidth - wallThickness / 2), wallHeight / 2, 0); // Position to the left
                        segmentBody.addShape(leftWallShape, leftWallOffset);


                        // Right Wall (sloped edge)
                        const rightWallShape = new CANNON.Box(new CANNON.Vec3(wallThickness / 2, wallHeight / 2, trackSegmentLength / 2));
                        const rightWallOffset = new CANNON.Vec3(trackWidth - wallThickness / 2, wallHeight / 2, 0); // Position to the right
                        segmentBody.addShape(rightWallShape, rightWallOffset);


                        segmentBody.position.copy(position);
                        segmentBody.quaternion.copy(orientation);
                        world.addBody(segmentBody);
                    }
                },
                (xhr) => {
                    console.log('Track model ' + (xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    console.error('An error occurred loading the track segment model:', error);
                    console.warn('Possible reason: GitHub Pages might not be enabled for your repository, or the file paths are incorrect. Please ensure GitHub Pages is enabled and the files are directly accessible at the provided URLs.');
                }
            );
        }


        // --- Event Handlers ---
        function onWindowResize() {
            const newWidth = canvas.offsetWidth; // Use global canvas
            const newHeight = canvas.offsetHeight; // Use global canvas
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }

        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(event.key.toLowerCase())) {
                event.preventDefault(); // Prevent page scrolling
            }
        }

        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        function startGame() {
            messageBox.style.display = 'none';
            gameRunning = true;
            gameTime = 0;

            // Reset player position and velocity
            if (playerBody) {
                playerBody.position.set(0, hoverHeight + 0.5, 0);
                playerBody.velocity.set(0, 0, 0);
                playerBody.angularVelocity.set(0, 0, 0);
                playerBody.quaternion.set(0, 0, 0, 1);
            }

            if (gameInterval) clearInterval(gameInterval); // gameInterval is now initialized to null
            gameInterval = setInterval(() => {
                if (gameRunning) {
                    gameTime++;
                    updateTimeDisplay();
                }
            }, 1000);

            if (!musicPlaying) {
                backgroundMusic.play().then(() => {
                    musicPlaying = true;
                }).catch(e => console.log("Music play blocked, user interaction needed:", e));
            }
        }

        function endGame() {
            gameRunning = false;
            clearInterval(gameInterval);
            messageTitle.textContent = "Race Over!";
            messageText.innerHTML = `Your final time: ${formatTime(gameTime)}<br><br>Press 'Start Race' to try again!`;
            startButton.textContent = "Restart Race";
            messageBox.style.display = 'flex';
        }

        function toggleMusic() {
            if (musicPlaying) {
                backgroundMusic.pause();
                musicPlaying = false;
                musicToggleButton.textContent = "Play Music";
            } else {
                backgroundMusic.play().then(() => {
                    musicPlaying = true;
                    musicToggleButton.textContent = "Pause Music";
                }).catch(e => console.log("Music play blocked, user interaction needed:", e));
            }
        }

        // --- Game Logic ---
        function updatePlayer() {
            if (!playerBody) return;

            const deltaTime = clock.getDelta(); // For consistent updates

            // Apply linear damping to simulate air resistance
            playerBody.linearDamping = 0.98; // Higher damping for hover feel
            playerBody.angularDamping = 0.9;

            // Hover System (Raycasting downwards)
            const rayFrom = playerBody.position;
            const rayTo = new CANNON.Vec3();
            rayFrom.vadd(new CANNON.Vec3(0, -hoverHeight - 10, 0), rayTo); // Ray goes downwards

            world.raycastAny(rayFrom, rayTo, (result) => {
                if (result.hasHit) {
                    const distance = rayFrom.distanceTo(result.hitPoint);
                    const heightDifference = hoverHeight - distance;

                    // Apply proportional force to correct height and dampen vertical velocity
                    const hoverForceMagnitude = heightDifference * hoverStrength - playerBody.velocity.y * hoverDamping;
                    const hoverForce = new CANNON.Vec3(0, hoverForceMagnitude, 0);
                    playerBody.applyForce(hoverForce, playerBody.position);

                    // Orient ship to track normal (more advanced, conceptual here)
                    // This would smooth out the ship's orientation based on the ground normal
                    // For now, simpler upright:
                    // const targetQuaternion = new CANNON.Quaternion();
                    // targetQuaternion.setFromVectors(new CANNON.Vec3(0, 1, 0), result.hitNormal);
                    // playerBody.quaternion.slerp(targetQuaternion, 0.1);
                } else {
                    // If no ground hit, apply a stronger downward force (gravity helper)
                    playerBody.applyForce(new CANNON.Vec3(0, -50, 0), playerBody.position);
                }
            });

            // Apply Thrust (forward/backward)
            const forwardVector = new CANNON.Vec3(0, 0, 1).applyQuaternion(playerBody.quaternion); // Ship's local Z-axis
            const currentSpeed = playerBody.velocity.dot(forwardVector);

            if (keys['w'] || keys['arrowup']) {
                playerBody.applyLocalForce(
                    new CANNON.Vec3(0, 0, acceleration * 10),
                    new CANNON.Vec3(0, 0, 0)
                );
            }
            if (keys['s'] || keys['arrowdown']) {
                playerBody.applyLocalForce(
                    new CANNON.Vec3(0, 0, -brakingForce * 10),
                    new CANNON.Vec3(0, 0, 0)
                );
            }

            // Apply Steering (Yaw Rotation)
            // Apply angular velocity directly
            if (keys['a'] || keys['arrowleft']) {
                playerBody.angularVelocity.y = steeringSpeed * 10;
            } else if (keys['d'] || keys['arrowright']) {
                playerBody.angularVelocity.y = -steeringSpeed * 10;
            } else {
                playerBody.angularVelocity.y *= 0.8; // Dampen when no input
            }

            // Limit player speed
            const velocityMagnitude = playerBody.velocity.length();
            if (velocityMagnitude > maxSpeed) {
                playerBody.velocity.normalize();
                playerBody.velocity.scale(maxSpeed, playerBody.velocity);
            }

            // Update speed display
            speedDisplay.textContent = Math.round(velocityMagnitude * 3.6); // Convert m/s to km/h

            // Ship Animations (placeholder logic)
            if (mixer) {
                mixer.update(deltaTime); // Update animations with delta time
                // Example: Activate steering animations
                if (keys['a'] || keys['arrowleft']) {
                    if (animations['Turn_Left']) animations['Turn_Left'].setEffectiveWeight(1);
                    if (animations['Turn_Right']) animations['Turn_Right'].setEffectiveWeight(0);
                } else if (keys['d'] || keys['arrowright']) {
                    if (animations['Turn_Right']) animations['Turn_Right'].setEffectiveWeight(1);
                    if (animations['Turn_Left']) animations['Turn_Left'].setEffectiveWeight(0);
                } else {
                    if (animations['Turn_Left']) animations['Turn_Left'].setEffectiveWeight(0);
                    if (animations['Turn_Right']) animations['Turn_Right'].setEffectiveWeight(0);
                }
                // Need to handle idle weight if other animations are active and then fade out
            }

            // End game if player falls off far below track
            if (playerBody.position.y < -50) {
                endGame();
            }
        }

        function updateCamera() {
            if (!playerBody || !playerMesh) return;

            const playerPos = playerBody.position;
            const playerQuat = playerBody.quaternion;

            // Camera follow behind and slightly above
            const relativeCameraOffset = new THREE.Vector3(0, 5, -15); // X, Y (height), Z (distance behind)

            // Apply player's rotation to the offset to get world coordinates
            const cameraOffset = relativeCameraOffset.applyQuaternion(playerMesh.quaternion);

            // Set camera position
            camera.position.copy(playerPos).add(cameraOffset);

            // Make camera look at the player
            camera.lookAt(playerPos.x, playerPos.y + 2, playerPos.z);
        }


        function updateTimeDisplay() {
            timeDisplay.textContent = formatTime(gameTime);
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(remainingSeconds).padStart(2, '0');
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta(); // Time elapsed since last frame

            if (gameRunning) {
                // Step the physics world forward
                world.step(1 / 60, delta); // Use delta for consistent physics updates

                // Update player's physics and visual
                updatePlayer();

                // Sync Three.js mesh with Cannon.js body
                if (playerMesh && playerBody) {
                    playerMesh.position.copy(playerBody.position);
                    playerMesh.quaternion.copy(playerBody.quaternion);
                }

                // Update camera position and look-at
                updateCamera();
            }

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Initialize on window load ---
        window.onload = function() {
            init();
            onWindowResize();
        };
    </script>
</body>
</html>
