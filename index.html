<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hover Game</title>
    <!-- Tailwind CSS for basic styling (e.g., info box) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic styling for body and canvas */
        body {
            margin: 0;
            overflow: hidden;
            font-family: "Inter", sans-serif;
            background-color: #1a1a2e; /* Match scene background */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Info display for speed and controls */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
        }
        /* Custom message box for alerts */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
        }
        .message-box button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            transition: background-color 0.3s ease;
        }
        .message-box button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <!-- Info overlay for controls and ship speed -->
    <div id="info">
        <p>Use W/S for acceleration/deceleration, A/D for steering.</p>
        <p>Ship Speed: <span id="shipSpeed">0.00</span></p>
    </div>
    <!-- Custom message box (instead of alert()) -->
    <div id="messageBox" class="message-box">
        <p id="messageContent"></p>
        <button onclick="hideMessageBox()">OK</button>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GLTFLoader for loading .glb models -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Cannon.js for 3D physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer; // Three.js components
        let world; // Cannon.js physics world
        let ship, shipBody; // Three.js mesh and Cannon.js body for the ship
        let trackSegment; // Three.js mesh for a single track segment
        let trackBodies = []; // Array to hold Cannon.js bodies for track segments

        // --- Physics Parameters ---
        const HOVER_HEIGHT = 2.0; // Desired height above ground for hovering
        const HOVER_FORCE_STRENGTH = 100; // Strength of the upward hover force
        const HOVER_DAMPING = 0.9; // Damping to reduce vertical oscillations
        const SHIP_MASS = 100; // Mass of the ship for physics calculations
        const FORWARD_ACCELERATION = 100; // Force applied for forward movement
        const BRAKE_DECELERATION = 50; // Force applied for braking/reverse movement
        const STEERING_FORCE = 50; // Torque applied for steering
        const MAX_SPEED = 150; // Maximum forward speed of the ship

        // --- Keyboard Input State ---
        const keys = {
            w: false, // Forward
            s: false, // Backward/Brake
            a: false, // Turn Left
            d: false  // Turn Right
        };

        // --- Custom Message Box Functions ---
        // Displays a message box to the user
        function showMessageBox(message) {
            document.getElementById('messageContent').innerText = message;
            document.getElementById('messageBox').style.display = 'block';
        }

        // Hides the message box
        function hideMessageBox() {
            document.getElementById('messageBox').style.display = 'none';
        }

        // --- Initialization Function ---
        // Sets up the Three.js scene, camera, renderer, and Cannon.js physics world
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // Dark blue background color

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Initial camera position (will be updated dynamically to follow the ship)
            camera.position.set(0, 10, -20);
            camera.lookAt(0, 0, 0); // Point camera towards the origin

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable anti-aliasing for smoother edges
            renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to full window
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens
            document.body.appendChild(renderer.domElement); // Add renderer's canvas to the DOM

            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white ambient light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Strong white directional light
            directionalLight.position.set(5, 10, 7); // Position the light source
            directionalLight.castShadow = true; // Enable shadows from this light (requires renderer.shadowMap.enabled = true)
            scene.add(directionalLight);

            // Physics world setup (Cannon.js)
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Set standard Earth gravity along the Y-axis
            world.broadphase = new CANNON.NaiveBroadphase(); // Simple broadphase for collision detection
            world.solver.iterations = 10; // Increase solver iterations for better stability (more accurate physics)

            // Load 3D models (ship and track)
            loadModels();

            // Add event listeners for window resize and keyboard input
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }

        // --- Model Loading Function ---
        // Loads the GLB models for the ship and track segment
        function loadModels() {
            const loader = new THREE.GLTFLoader();

            // Load Ship Model
            loader.load(
                'https://raw.githubusercontent.com/maxedoutpotato/Hover.Game.Test/main/Game.Ship.glb',
                function (gltf) {
                    ship = gltf.scene; // Get the scene from the loaded GLTF
                    ship.scale.set(0.5, 0.5, 0.5); // Scale down the ship to a suitable size
                    ship.position.set(0, HOVER_HEIGHT, 0); // Initial position slightly above ground
                    scene.add(ship); // Add ship to the Three.js scene

                    // Create Cannon.js body for the ship
                    // Using a simple box shape to approximate the ship's collision volume
                    const shipShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.5, 3));
                    shipBody = new CANNON.Body({ mass: SHIP_MASS, shape: shipShape });
                    shipBody.position.copy(ship.position); // Initialize physics body position
                    world.addBody(shipBody); // Add ship body to the physics world

                    // Link Three.js mesh to Cannon.js body for easy access
                    ship.userData.physicsBody = shipBody;

                    console.log('Ship loaded:', ship);
                },
                undefined, // Optional: progress callback
                function (error) {
                    console.error('Error loading ship model:', error);
                    showMessageBox('Failed to load ship model. Please check the browser console for details.');
                }
            );

            // Load Track Segment Model and create an array of segments
            loader.load(
                'https://raw.githubusercontent.com/maxedoutpotato/Hover.Game.Test/main/Game.Track.Section.001.glb',
                function (gltf) {
                    trackSegment = gltf.scene;
                    trackSegment.scale.set(10, 10, 10); // Scale up the track segment to a larger size

                    // Get the bounding box of the track segment to determine its length
                    const bbox = new THREE.Box3().setFromObject(trackSegment);
                    const trackLength = bbox.max.z - bbox.min.z; // Calculate length along Z-axis
                    console.log('Track segment length (scaled):', trackLength * trackSegment.scale.z);

                    const NUM_SEGMENTS = 20; // Number of track segments to create
                    for (let i = 0; i < NUM_SEGMENTS; i++) {
                        const segmentInstance = trackSegment.clone(); // Create a clone of the original segment
                        // Position segments sequentially along the Z-axis
                        segmentInstance.position.z = i * trackLength * trackSegment.scale.z;
                        scene.add(segmentInstance); // Add segment instance to the Three.js scene

                        // Create Cannon.js bodies for the track segments
                        // Using a simple box shape for the entire segment's collision.
                        // For more precise collision, individual parts of the track model would need to be processed
                        // and converted to more complex Cannon.js shapes (e.g., Trimesh).
                        const trackShape = new CANNON.Box(new CANNON.Vec3(
                            (bbox.max.x - bbox.min.x) / 2 * trackSegment.scale.x, // Half width
                            (bbox.max.y - bbox.min.y) / 2 * trackSegment.scale.y, // Half height
                            trackLength / 2 * trackSegment.scale.z // Half depth
                        ));
                        const trackBody = new CANNON.Body({ mass: 0 }); // Mass 0 makes it a static (immovable) body
                        trackBody.addShape(trackShape);
                        trackBody.position.copy(segmentInstance.position); // Set physics body position
                        world.addBody(trackBody); // Add track body to the physics world
                        trackBodies.push(trackBody); // Store reference to the track body
                        segmentInstance.userData.physicsBody = trackBody; // Link Three.js mesh to Cannon.js body
                    }
                    console.log('Track segments loaded and array created.');
                },
                undefined, // Optional: progress callback
                function (error) {
                    console.error('Error loading track model:', error);
                    showMessageBox('Failed to load track model. Please check the browser console for details.');
                }
            );
        }

        // --- Event Handlers ---
        // Handles window resizing to keep the scene responsive
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; // Update camera aspect ratio
            camera.updateProjectionMatrix(); // Recalculate projection matrix
            renderer.setSize(window.innerWidth, window.innerHeight); // Resize renderer
        }

        // Handles key presses for movement and steering
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyD': keys.d = true; break;
            }
        }

        // Handles key releases
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyD': keys.d = false; break;
            }
        }

        // --- Animation Loop ---
        // Updates the physics world, ship position, and camera every frame
        function animate() {
            requestAnimationFrame(animate); // Request next animation frame

            const deltaTime = 1 / 60; // Fixed time step for physics simulation (60 FPS)

            // Update physics world
            world.step(deltaTime);

            // Ensure ship and its physics body are loaded before updating
            if (ship && shipBody) {
                // --- Hover Physics Implementation (Raycasting) ---
                const raycaster = new THREE.Raycaster();
                const down = new THREE.Vector3(0, -1, 0); // Ray points directly downwards
                const shipWorldPosition = new THREE.Vector3();
                ship.getWorldPosition(shipWorldPosition); // Get the ship's current world position

                raycaster.set(shipWorldPosition, down); // Set raycaster origin and direction
                // Intersect with all objects in the scene to find the ground
                const intersects = raycaster.intersectObjects(scene.children, true);

                let groundFound = false;
                for (let i = 0; i < intersects.length; i++) {
                    const intersect = intersects[i];
                    // Check if the intersected object is part of a track segment's visual mesh
                    // This is a simplified check. A more robust solution might involve specific collision layers.
                    if (intersect.object.parent && intersect.object.parent.userData.physicsBody && trackBodies.includes(intersect.object.parent.userData.physicsBody)) {
                        const distanceToGround = intersect.distance;

                        // Apply upward hover force if too close to the ground
                        if (distanceToGround < HOVER_HEIGHT) {
                            // Force proportional to how much the ship has "penetrated" the hover height
                            const hoverForce = new CANNON.Vec3(0, HOVER_FORCE_STRENGTH * (HOVER_HEIGHT - distanceToGround), 0);
                            shipBody.applyForce(hoverForce, shipBody.position);
                            groundFound = true;
                        }
                        // Apply damping to reduce vertical oscillations (bouncing)
                        const dampingForce = new CANNON.Vec3(0, -shipBody.velocity.y * HOVER_DAMPING, 0);
                        shipBody.applyForce(dampingForce, shipBody.position);
                        break; // Only consider the closest ground intersection
                    }
                }

                // --- Ship Movement and Steering ---
                // Get the ship's current forward direction based on its rotation
                const currentForward = new CANNON.Vec3();
                shipBody.quaternion.vmult(new CANNON.Vec3(0, 0, 1), currentForward); // (0,0,1) is local Z-axis (forward)

                if (keys.w) {
                    // Forward acceleration
                    // Check if current speed in forward direction is below max speed
                    if (shipBody.velocity.dot(currentForward) < MAX_SPEED) {
                        shipBody.applyForce(currentForward.scale(FORWARD_ACCELERATION), shipBody.position);
                    }
                } else if (keys.s) {
                    // Braking/Reverse
                    shipBody.applyForce(currentForward.scale(-BRAKE_DECELERATION), shipBody.position);
                }

                // Apply steering forces (torque around Y-axis)
                if (keys.a) {
                    // Turn left (positive torque around Y)
                    shipBody.applyTorque(new CANNON.Vec3(0, STEERING_FORCE, 0));
                }
                if (keys.d) {
                    // Turn right (negative torque around Y)
                    shipBody.applyTorque(new CANNON.Vec3(0, -STEERING_FORCE, 0));
                }

                // Update Three.js ship's position and rotation from Cannon.js physics body
                ship.position.copy(shipBody.position);
                ship.quaternion.copy(shipBody.quaternion);

                // --- Camera Follow ---
                // Define the offset of the camera relative to the ship
                const cameraOffset = new THREE.Vector3(0, 5, -15); // x, y (above), z (behind)
                // Apply the ship's current rotation to the camera offset
                cameraOffset.applyQuaternion(ship.quaternion);
                // Set camera position to ship's position plus the rotated offset
                camera.position.copy(ship.position).add(cameraOffset);
                camera.lookAt(ship.position); // Make the camera look directly at the ship

                // Update ship speed display in the info box
                const speed = shipBody.velocity.length(); // Get magnitude of velocity vector
                document.getElementById('shipSpeed').innerText = speed.toFixed(2);
            }

            // Render the scene with the camera
            renderer.render(scene, camera);
        }

        // --- Start Game on Window Load ---
        // Ensures all resources are loaded before starting the animation loop
        window.onload = function () {
            init(); // Initialize the scene and physics
            animate(); // Start the animation loop
        }
    </script>
</body>
</html>
