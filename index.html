<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hover Game Test</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Inter', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; } /* Canvas fills the entire viewport */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 2em;
            z-index: 1000;
            flex-direction: column;
        }
        #loading-bar-container {
            width: 50%;
            background: #333;
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 20px;
        }
        #loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00f, #0f0);
            border-radius: 5px;
            transition: width 0.1s linear;
        }
    </style>
    <!-- Include Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include GLTFLoader for loading GLB models -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Include DRACOLoader for handling Draco compressed GLB models -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
</head>
<body>
    <div id="loading-screen">
        <p>Loading Game Assets...</p>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
    </div>
    <script type="module">
        // Global variables for scene, camera, renderer, and models
        let scene, camera, renderer;
        let ship;
        let mixer; // For animations (if any in GLB)

        // Game state variables
        let keysPressed = {}; // Object to track currently pressed keys
        const SHIP_FORWARD_SPEED = 0.5; // Speed at which the track moves (simulating ship forward)
        const SHIP_LATERAL_SPEED = 0.2; // Speed for left/right movement of the ship
        const SHIP_ROTATION_SPEED = 0.05; // Speed for ship rotation around its Y-axis

        let trackSegments = []; // Array to hold all track segment objects
        let trackDepth = 0; // Will store the calculated depth (length) of a single track segment

        // Camera constants for easy adjustment
        const CAMERA_DISTANCE_Z = 3.0; // Distance behind ship (increased from 1.5 to 3.0)
        const CAMERA_HEIGHT_Y = 1.2; // Height above ship (increased from 0.8 to 1.2)
        const CAMERA_LOOK_AT_Y_OFFSET = 0.5; // How much above the ship's base the camera looks

        // Event listeners for keyboard input
        document.addEventListener('keydown', (event) => {
            keysPressed[event.code] = true;
        });

        document.addEventListener('keyup', (event) => {
            keysPressed[event.code] = false;
        });

        // Initialize the scene, camera, and renderer
        function init() {
            // Create a new Three.js scene
            scene = new THREE.Scene();
            // Set background color to a dark blue/purple for a futuristic feel
            scene.background = new THREE.Color(0x1a0a30);

            // Set up the camera (PerspectiveCamera)
            // FOV: Field of View (vertical, in degrees)
            // Aspect: Aspect ratio (width / height)
            // Near: Near clipping plane
            // Far: Far clipping plane
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Create a WebGL renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            // Set renderer size to fill the window
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Append the renderer's DOM element to the body
            document.body.appendChild(renderer.domElement);

            // Add lighting to the scene
            addLighting();

            // Load the GLB models
            loadModels();

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        // Function to add various lights to the scene
        function addLighting() {
            // Ambient light: illuminates all objects equally from all directions
            // Does not cast shadows, good for general brightness
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Color, Intensity
            scene.add(ambientLight);

            // Directional light: acts like sunlight, coming from a specific direction
            // Good for casting shadows and defining form
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Color, Intensity
            directionalLight.position.set(5, 10, 7); // Position of the light source
            directionalLight.castShadow = true; // Enable shadow casting for this light
            scene.add(directionalLight);

            // Optional: Add a second directional light for more dynamic lighting
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(-5, 5, -5);
            scene.add(directionalLight2);

            // Optional: Add a hemisphere light for more natural outdoor lighting
            // Sky color, ground color, intensity
            const hemisphereLight = new THREE.HemisphereLight(0xb1e1ff, 0xb97a20, 0.5);
            scene.add(hemisphereLight);
        }

        // Function to load 3D models (GLB format)
        function loadModels() {
            const gltfLoader = new THREE.GLTFLoader(loadingManager);

            // Configure DRACOLoader for GLTFLoader
            const dracoLoader = new THREE.DRACOLoader();
            // Set the path to the Draco decoder files (usually in /examples/js/libs/draco/)
            // These files should be placed in your project's root or a specified path
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            gltfLoader.setDRACOLoader(dracoLoader);

            // Load the ship model
            gltfLoader.load(
                'Game.Ship.glb',
                function (gltf) {
                    ship = gltf.scene;
                    // Scale the ship 10 times larger
                    ship.scale.set(1.0, 1.0, 1.0);
                    ship.position.set(0, 0.5, 0); // Initial position relative to track
                    // Rotate the ship 180 degrees around the Y-axis so it faces the negative Z direction
                    ship.rotation.y = Math.PI;
                    scene.add(ship);

                    // If the ship has animations, set up an animation mixer
                    // Play only the 'Armature.Idle' animation
                    if (gltf.animations && gltf.animations.length) {
                        mixer = new THREE.AnimationMixer(ship);
                        const idleClip = THREE.AnimationClip.findByName(gltf.animations, 'Armature.Idle');
                        if (idleClip) {
                            mixer.clipAction(idleClip).play();
                        } else {
                            console.warn("Animation 'Armature.Idle' not found. Playing first available animation.");
                            // Fallback: play the first animation if idle not found
                            if (gltf.animations.length > 0) {
                                mixer.clipAction(gltf.animations[0]).play();
                            }
                        }
                    }

                    // Initial camera position relative to the ship
                    // We calculate this dynamically in animate() for continuous following
                    // This initial set is just for the first frame before animate loop runs
                    const cameraLocalOffset = new THREE.Vector3(0, CAMERA_HEIGHT_Y, CAMERA_DISTANCE_Z);
                    const cameraWorldPosition = new THREE.Vector3();
                    cameraWorldPosition.copy(cameraLocalOffset).applyMatrix4(ship.matrixWorld);
                    camera.position.copy(cameraWorldPosition);
                    camera.lookAt(ship.position.x, ship.position.y + CAMERA_LOOK_AT_Y_OFFSET, ship.position.z);
                },
                undefined, // onProgress callback (handled by LoadingManager)
                function (error) {
                    console.error('An error occurred while loading the ship model:', error);
                }
            );

            // Load the track model and duplicate it
            gltfLoader.load(
                'Game.Track.Section.001.glb',
                function (gltf) {
                    const singleTrackSegment = gltf.scene;
                    singleTrackSegment.scale.set(1, 1, 1); // Ensure correct scale for the base segment

                    // Calculate bounding box to get depth (length) of the track segment
                    // This is crucial for correctly spacing the duplicates
                    const bbox = new THREE.Box3().setFromObject(singleTrackSegment);
                    trackDepth = bbox.max.z - bbox.min.z;
                    console.log("Calculated Track segment depth:", trackDepth);

                    const numberOfSegments = 10;
                    // Create and position track segments
                    for (let i = 0; i < numberOfSegments; i++) {
                        const clonedTrack = singleTrackSegment.clone(); // Clone the original track
                        // Position each segment along the negative Z-axis to extend the track backward
                        // We multiply by 'i' to place them consecutively
                        clonedTrack.position.set(0, 0, -i * trackDepth);
                        scene.add(clonedTrack);
                        trackSegments.push(clonedTrack); // Store in the array for later manipulation
                    }
                },
                undefined, // onProgress callback (handled by LoadingManager)
                function (error) {
                    console.error('An error occurred while loading the track model:', error);
                }
            );
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate); // Request the next frame

            const delta = 0.016; // Approximate time per frame (60 FPS)

            // Update animations if mixer exists
            if (mixer) {
                mixer.update(delta);
            }

            if (ship) {
                // Ship Lateral Movement (A/D or Left/Right Arrow)
                if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) {
                    ship.position.x -= SHIP_LATERAL_SPEED;
                }
                if (keysPressed['KeyD'] || keysPressed['ArrowRight']) {
                    ship.position.x += SHIP_LATERAL_SPEED;
                }

                // Ship Rotation (Yaw)
                // Adjust ship's rotation based on A/D keys for turning
                if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) {
                    ship.rotation.y += SHIP_ROTATION_SPEED;
                }
                if (keysPressed['KeyD'] || keysPressed['ArrowRight']) {
                    ship.rotation.y -= SHIP_ROTATION_SPEED;
                }

                // Track Scrolling (W/S or Up/Down Arrow)
                // This simulates the ship moving forward/backward by moving the track
                if (keysPressed['KeyW'] || keysPressed['ArrowUp']) {
                    for (let i = 0; i < trackSegments.length; i++) {
                        trackSegments[i].position.z += SHIP_FORWARD_SPEED; // Move track towards camera
                        // If a track segment moves too far forward (past the camera's view)
                        // reposition it to the very end of the track chain
                        if (trackSegments[i].position.z > camera.position.z + trackDepth) {
                            trackSegments[i].position.z -= trackSegments.length * trackDepth;
                        }
                    }
                }
                if (keysPressed['KeyS'] || keysPressed['ArrowDown']) {
                    for (let i = 0; i < trackSegments.length; i++) {
                        trackSegments[i].position.z -= SHIP_FORWARD_SPEED; // Move track away from camera
                        // If a track segment moves too far backward (out of view behind)
                        // reposition it to the very beginning of the track chain
                        if (trackSegments[i].position.z < camera.position.z - (trackSegments.length * trackDepth) - trackDepth) {
                            trackSegments[i].position.z += trackSegments.length * trackDepth;
                        }
                    }
                }

                // Camera following logic:
                // Define a local offset for the camera relative to the ship's origin
                const cameraLocalOffset = new THREE.Vector3(0, CAMERA_HEIGHT_Y, CAMERA_DISTANCE_Z);
                // Create a new vector for the camera's world position
                const cameraWorldPosition = new THREE.Vector3();
                // Apply the ship's world matrix to the local offset to get the camera's world position
                // This makes the camera follow the ship's rotation and position dynamically
                cameraWorldPosition.copy(cameraLocalOffset).applyMatrix4(ship.matrixWorld);
                camera.position.copy(cameraWorldPosition);

                // Make the camera look at the ship's position, or slightly ahead/above it
                // The lookAt Y target is adjusted to make the camera look slightly downwards
                camera.lookAt(ship.position.x, ship.position.y + CAMERA_LOOK_AT_Y_OFFSET, ship.position.z);
            }

            renderer.render(scene, camera); // Render the scene
        }

        // Handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize the game when the window loads
        window.onload = function () {
            init();
        };
    </script>
</body>
</html>
